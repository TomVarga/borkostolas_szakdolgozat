% LaTeX mintafájl szakdolgozat és diplomamunkáknak az
% SZTE Informatikai Tanszekcsoportja által megkövetelt
% formai követelményeinek megvalósításához
% Modositva: 2011.04.28 Nemeth L. Zoltan
% A fájl használatához szükséges a magyar.ldf 2005/05/12 v1.5-ös vagy késõbbi verziója
% ez letölthetõ a http://www.math.bme.hu/latex/ weblapról, a magyar nyelvû szedéshez
% Hasznos információk, linekek, LaTeX leirasok a www.latex.lap.hu weboldalon vannak.
%


\documentclass[12pt]{report}

%Magyar nyelvi támogatás (Babel 3.7 vagy késõbbi kell!)
\def\magyarOptions{defaults=hu-min}
\usepackage[magyar]{babel}

%Az ékezetes betûk használatához:
\usepackage{t1enc}% ékezetes szavak automatikus elválasztásához
\usepackage[latin2]{inputenc}% ékezetes szavak beviteléhez

% A formai kovetelmenyekben megkövetelt Times betûtípus hasznalata:
\usepackage{times}

%Az AMS csomagjai
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

%A fejléc láblécek kialakításához:
\usepackage{fancyhdr}

%Természetesen további csomagok is használhatók,
%például ábrák beillesztéséhez a graphix és a psfrag,
%ha nincs rájuk szükség természetesen kihagyhatók.
\usepackage{graphicx}
\usepackage{psfrag}

\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[draft]{pgf}
\usepackage{setspace}
\usepackage{todonotes}
\usepackage{pgf, tikz}

\usepackage{scrbase}
\usepackage{listings}
\newcaptionname{magyar}{\lstlistingname}{Kód részlet}
\lstset{language=sql,
	keywordstyle=\color{BlueGreen},
	stringstyle=\color{BrickRed},
	commentstyle=\color{OliveGreen},
	morecomment=[l][\color{OliveGreen}]{\#},
	breaklines=true, postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

\usetikzlibrary{arrows, automata}

%Tételszerû környezetek definiálhatók, ezek most fejezetenkent egyutt szamozodnak, pl.
\newtheorem{tét}{Tétel}[chapter]
\newtheorem{defi}[tét]{Definíció}
\newtheorem{lemma}[tét]{Lemma}
\newtheorem{áll}[tét]{Állítás}
\newtheorem{köv}[tét]{Következmény}

%Ha a megjegyzések és a példak szövegét nem akarjuk dõlten szedni, akkor
%az alábbi parancs után kell õket definiální:
\theoremstyle{definition}
\newtheorem{megj}[tét]{Megjegyzés}
\newtheorem{pld}[tét]{Példa}

%Margók:
\hoffset -1in
\voffset -1in
\oddsidemargin 35mm
\textwidth 150mm
\topmargin 15mm
\headheight 10mm
\headsep 5mm
\textheight 237mm

%Hyperlinkek:
\usepackage{hyperref}


\begin{document}

%A FEJEZETEK KEZDÕOLDALAINAK FEJ ES LÁBLÉCE:
%a plain oldalstílust kell átdefiniálni, hogy ott ne legyen fejléc:
\fancypagestyle{plain}{%
%ez mindent töröl:
\fancyhf{}
% a láblécbe jobboldalra kerüljön az oldalszám:
\fancyfoot[R]{\thepage}
%elválasztó vonal sem kell:
\renewcommand{\headrulewidth}{0pt}
}

%A TÖBBI OLDAL FEJ ÉS LÁBLÉCE:
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Minõségkinyerés borkóstolási adatokból, web és android alkalmazás fejlesztés}
\fancyfoot[R]{\thepage}


%A címoldalra se fej- se lábléc nem kell:
\thispagestyle{empty}

\begin{center}
\vspace*{1cm}
{\Large\bf Szegedi Tudományegyetem}

\vspace{0.5cm}

{\Large\bf Informatikai Tanszékcsoport}

\vspace*{3.8cm}


{\LARGE\bf Minõségkinyerés borkóstolási adatokból, web és android alkalmazás fejlesztés}


\vspace*{3.6cm}

{\Large Szakdolgozat}
% vagy {\Large Szakdolgozat}

\vspace*{4cm}

%Értelemszerûen megváltoztatandó:
{\large
\begin{tabular}{c@{\hspace{4cm}}c}
\emph{Készítette:}     &\emph{Témavezetõ:}\\
\bf{Varga Tamás}  &\bf{Dr. Csendes Tibor}\\
Programtervezõ Informatikus     &tanszékvezetõ egyetemi tanár\\
hallgató&
\end{tabular}
}

\vspace*{2.3cm}

{\Large
Szeged
\\
\vspace{2mm}
2015
}
\end{center}


%A tartalomjegyzék:
\tableofcontents

\onehalfspacing
%A \chapter* parancs nem ad a fejezetnek sorszámot
\chapter*{Feladatkiírás}
%A tartalomjegyzékben mégis szerepeltetni kell, mint szakasz(section) szerepeljen:
\addcontentsline{toc}{section}{Feladatkiírás}
A hallgató feladata egy olyan web és hozzá tartozó android alkalmazás készítése, amely képes borkóstolás során gyûjtött bor értékelések alapján több különbözõ algoritmus használatával a kóstolók rangsorolására. A web és android alkalmazásoknak képeseknek kell lenniük egymás közötti szinkronizációra, több felhasználó kezelésére valamint a bevitt adatok és az alkalmazás állapotaink tárolására. Az android alkalmazásnak offline módban is használható kell hogy legyen.

\chapter*{Tartalmi összefoglaló}
\addcontentsline{toc}{section}{Tartalmi összefoglaló}

\paragraph{A téma megnevezése}
Minõségkinyerés borkóstolási adatokból, web és android alkalmazás fejlesztés

\paragraph{A feladat megfogalmazása}
Web és android alkalmazás fejlesztése, amely képes bor értékelések alapján már létezõ algoritmusok által rangsorolni a borkóstolókat. A mobil alkalmazás felhasználó barát megvalósítása, mely bármilyen körülmény mellet valós idejû adat bevitelt is garantál.

\paragraph{A megoldási mód}
A web alkalmazás a következõ címekrõl érhetõ el:
\begin{itemize}
	\item \url{http://bor.tvarga.hu}
\end{itemize}

Az android alkalmazás letölthetõ bármelyik fent említett URL -rõl a jobb oldali floating menün keresztül, vagy az alábbi közvetlen linken: \hyperlink{http://bor.tvarga.hu/borkostolas.apk}{borkostolas.apk}

\paragraph{Alkalmazott eszközök, módszerek}
\begin{itemize}
    \item Web alkalmazás: 
    \subitem Programozási nyelvek: PHP, JavaScript, MySQL
    \subitem Fejlesztõi környezetek: SublimeText, PhpStorm
    \item Android alkalmazás:
    \subitem Programozási nyelvek: Java
    \subitem Fejlesztõi környezetek: Android Studio
    \item Verziókezelés: GitHub
\end{itemize}

\paragraph{Kulcsszavak}
Android, PHP, JavaScript, Borkóstolás


\chapter*{Bevezetés}
\addcontentsline{toc}{section}{Bevezetés}

Borkóstolók rangsorolásával illetve minõségkinyeréssel valamint borversenyek lebonyolításával már elõttem is többen foglalkoztak. Bár még van kutatni való ezen a területen, jól mûködõ algoritmus már több is ismert ilyen jellegû feladatok megoldására. Ezért ennek a szakdolgozatnak nem is újabb algoritmusok kifejlesztése vagy már meglévõk továbbfejlesztése a fõ célja. Mivel található több olyan web alkalmazás is, mely egy specifikus egyszerû algoritmust vagy talán egy sokat tesztelt komplexebbet használ, mégsem létezek egy közismert, modern és felhasználóbarát alkalmazás, amely egy igényes felhasználói felületen keresztül bemutatná ezen algoritmusok mûködését lehetõvé téve hogy nyomon kövessük akár saját laikus eredményeinket neves szakértõkhöz viszonyítva.

Mivel a mai világban a mobil eszközök egyre nagyobb teret hódítanak, az is célom volt hogy egy olyan mobil (android) alkalmazás társuljon a web alkalmazáshoz mely egy könnyen kezelhetõ intuitív felületen keresztül lehetõvé tegye a rendszer használatát, bizonyos funkciókat még offline üzemmódban is elérhetõvé téve, kielégítve napjaink átlagos felhasználóinak igényeit. 

A dolgozat elején röviden bemutatom az alkalmazás által használt algoritmusokat. Majd rátérek a weboldal és a mögötte álló rendszerek felépítésére, a hozzájuk társuló fejlesztõi környezetek és eszközök rövid ismertetésére. Ezt majd a mobil (android) alkalmazás bemutatás követ, melynél szintén kitérek a rendszer felépítésére illetve a megvalósítást lehetõvé tevõ eszközökre,  erõforrásokra. Logikusan ezt a két alkalmazási felület (web és mobil) összefûzésének megvalósítása követi. Az összefoglalás elõtt néhány teszten keresztül bemutatom a rendszer megbízhatóságát. Legvégül pedig kitérek néhány olyan dologra mely segítette a munkámat, mint például verziókezelõ rendszerek használata.

\chapter{Borkóstoló algoritmusok}

Ezen szakdolgozat keretében a CoHITS algoritmus került implementálásra, mely mellé csatlakozott néhány Borkóstolás projekt \cite{Borkóstolás projekt} keretében használt már Szilárd Iván által implementált algoritmus, mint a Hamming, Koszinusz, Precedencia, Összefüggõségi. Ezeknél az algoritmusoknál a PageRank egy hasonlósági mátrixon propagál, ennek elemeit a borkóstolók páronkénti értékeléseinek inverz távolságából kapjuk a hozzájuk illõ távolság mértékek alkalmazásával (Hamming távolság, koszinusz távolság, precedencia távolság, összefüggõsségi távolság) \cite{Borkóstolás projekt}.

\section{CoHITS}
A CoHITS algoritmus a PageRank és a HITS algoritmuson egy kiterjesztett változata \cite{CoHITS}. A PageRank algoritmust Sergey Brin és Larry Page fejlesztette ki a Google keresõ használatához \cite{PageRank} keresési találatok fontossági rangsorolásnak meghatározása céljából. Tõlük függetlenül Jon Kleinberg egy hasonló koncepcióval állt elõ mely ugyan ilyen jellegû feladatot látott el \cite{HITS}.

Legyen $ X $ és $ Y $ a kóstolók és borok. Ugyan abból a $p^0$ értékbõl indulunk ki minden $x_{i} \in X $ kóstolónál. Ekkor legyen $w'\left(\overrightarrow{x_{i}y_{j}}\right)$ az az értékelés amit $y_j$ bor kapott az $x_i$ kóstolótól és legyen $w\left(\overrightarrow{x_{i}y_{j}}\right)=w'\left(\overrightarrow{x_{i}y_{j}}\right)/\sum_{j \in Y}w'\left(\overrightarrow{x_{i}y_{j}}\right)$ a normalizáltja. Továbbá legyen $q_j^0$ érték (az $y_j$ borra) az értékelések átlaga. Majd definiáljuk a $w\left(\overleftarrow{x_iy_j}\right)$ az alábbi képen: tegyük fel hogy $y_j$ bort $l$ különbözõ kóstoló kóstolta és legyen

\begin{equation} \label{CoHITS sum of diff}
D=\sum_{i \in X}|q_j^0-w'\left(\overrightarrow{x_iy_j}\right)|,
\end{equation}

az összegek különbsége az átlagtól az $y_j$ borra tekintve. Végül, legyen

\begin{equation} \label{CoHITS transition probability}
w\left(\overleftarrow{x_iy_j}\right)=\dfrac{|\sum_{i \in X}|q_j^0-w'\left(\overrightarrow{x_iy_j}\right)||}{\left(l-1\right)D}
\end{equation} 

Ekkor $\sum_{i \in X}w\left(\overleftarrow{x_iy_j}\right)=1$ tehát minden $w\left(\overleftarrow{x_iy_j}\right)$ súlyra lehet úgy tekinteni mint egy átmeneti valószínûség $y_j$-bõl $x_i$-be. Az \ref{CoHITS gráf} ábra a súlyok kiszámítására mutat egy konkrét példát.

A két kóstoló közti súly $x_i$ és $x_j$ úgy definiálható mint egy rejtett átmeneti valószínûség 1 által definiálva. Ekkor a $p=W_{xp}$ HITS egyenlet  $p=\left(p_1,p_2,...,p_m\right)$ megoldás megadja a kóstolók rangsorát.

\begin{figure}[!h]
	\begin{center}
\begin{tikzpicture}[
> = stealth, % arrow head style
shorten > = 1pt, % don't touch arrow head to node
auto,
node distance = 4cm, % distance between nodes
semithick % line style
]

\tikzstyle{every state}=[
draw = black,
thick,
fill = white,
minimum size = 22mm
]

\node[state] (taster1) {Kóstoló 1};
\node[state] (wine2) [below of=taster1] {Bor 2};
\node[state] (wine1) [left of=wine2] {Bor 1};
\node[state] (wine3) [right of=wine2] {Bor 3};

\path[->] (taster1) edge node {2/12} (wine1);
\path[->] (taster1) edge node {3/12} (wine2);
\path[->] (taster1) edge node {7/12} (wine3);

\node[state] (taster1b) [below of=wine1] {Kóstoló 1};
\node[state] (taster2) [below of=wine2] {Kóstoló 2};
\node[state] (taster3) [below of=wine3] {Kóstoló 3};
\node[state] (wine1b) [below of=taster2] {Bor 1};

\path[->] (wine1b) edge node {4/12} (taster1b);
\path[->] (wine1b) edge node {5/12} (taster2);
\path[->] (wine1b) edge node {3/12} (taster3);


\end{tikzpicture}
	\end{center}
	\caption{\label{CoHITS gráf} A gráf súlyai amikor a Kóstoló 1 a 20, 30 és 70 értékeléseket adott a Bor 1, Bor 2 és Bor 3 borokra, valamint a Bor 1 a 20, 30 és 70 értékeléseket kapott a Kóstoló 1, Kóstoló 2 és Kóstoló 3 aktól.}
\end{figure}

Tehát látható, hogy az így elõ állított algoritmust alkalmazni lehet egy borkóstolási gráfra kóstolók rangsorolásának céljából az õ képességeik és szakmai hozzáértésük alapján. Általánosságban az figyelhetõ meg, hogy az így elõálló rangsor jobban teljesít mint más egyszerû statisztikai algoritmusok. Ki tudja szûrni a hozzá nem értõ kóstolókat \cite{CoHITS}.

\section{Hamming}
A Hamming-távolságot \eqref{Hamming-távolság} többnyire vektorok, karaktersorozatok valamint bitminták közötti eltérések kimutatására használják. A Hamming-távolság csak azt mondja meg, hogy hány helyen nem illeszkedik az egyik minta a másikra. Legyen $ S_{1} $ és $ S_{2} $ két azonos hosszú minta.

\begin{equation} \label{Hamming-távolság}
D_{Hamming}\left ( S_{1},S_{2} \right )=\sum_{p=0}^{|S_{1}|}S_{1}\left(p\right)\neq S_{2}\left(p\right)
\end{equation}

Ez a távolság nem lesz megfelelõ mérték vizsgálathoz mivel nem túl informatív.

\section{Koszinusz}
Legyen $ \pi^1 $ és $ \pi^2 $ két permutáció-vektor. Ekkor ezek koszinusz távolságát az \eqref{Koszinusz-távolság} képlet szerint számíthatjuk ki, ahol $ || \cdot || $ az euklideszi normát jelöli.

\begin{equation} \label{Koszinusz-távolság}
D_{cos}\left(\pi^1,\pi^2\right)=1-\dfrac{\pi^1\cdot\pi^2}{||\pi^1||\cdot||\pi^2||}
\end{equation}

\section{Precedencia}
A precedencia távolság meghatározásához definiálnunk kell elõször a precedencia mátrix fogalmát. Egy $ \pi $, $ n $ hosszúságú permutáció precedencia mátrixa egy olyan bináris elemekbõl álló $ n \times n $-es $ P $ mátrix, melyben $ P_{\pi_{i}\pi_{j}}=1, i<j $ egyébként $P_{ij}=0$, azaz a permutáció elemeinek sorrendjét kódoljuk egy bináris mátrixszal. A precedencia távolságot két $\pi^1$ és $\pi^2$ permutáció között ($P_{1}$ és $P_{2}$ a nekik megfelelõ precedencia mátrix) a precedencia mátrixuk egyezõ nem nulla elemeinek számából számíthatjuk ki \eqref{Precedencia-távolság} szerint.

\begin{equation} \label{Precedencia-távolság}
D_{prec}\left(\pi^1, \pi^2\right)=\dfrac{n\left(n-1\right)}{2}-\sum_{i=1}^{n}\sum_{j=1}^{n}P_{ij}^1P_{ij}^2
\end{equation}

\section{Összefüggõségi}
Az összefüggõsségi távolság a szomszédos elemek azonos elõfordulásából számítható. Legyen a két permutációnk $\pi^1$ és $\pi^2$, $n$ hosszúságúak, és a szomszédos elemek azonos elõfordulásának száma $n_{adj}$.

Szemléletesen: Legyen $N_{\pi}$ a $\pi$ permutáció összefüggõségi mátrixa. Kezdetben minden eleme legyen $0$, majd a $\pi$ permutáció minden $i$ elemére az $N_{pi}\left(\pi_{i},\pi{i+1}\right)=1$. A $\pi^1$ és $\pi^2$ permutációra kiszámoljuk az $N_{\pi^1}$ és $N_{\pi^2}$ mátrixokat. $n_{adj}$ az $N_{\pi^1}$
és$N_{\pi^2}$ mátrixban azonos cellában lévõ $1$-esek száma. 

Ekkor az összefüggõsségi távolság \eqref{Összeföggõségi-távolság} szerint számítandó.
\begin{equation} \label{Összeföggõségi-távolság}
D_{adj}\left(\pi^1,\pi^2\right)=n-n_{adj}-1
\end{equation}
\cite{Borkóstolás projekt}

\chapter{A weboldal}

A web oldal kialakításánál számomra fontos szempont volt, hogy az egy letisztult könnyen kezelhetõ felületet prezentáljon a felhasználók felé. Ennek érdekében már a kezdetektõl folyton szem elõtt tartottam hogy a stilisztikai elemek hogyan viszonyulnak egymáshoz, illetve külön figyelmet fordítottam arra, hogy a CSS (\textbf{C}ascading \textbf{S}tyle \textbf{S}heets) konzisztens megjelenést biztosítson a web alkalmazás minden oldalán. Ez azért is jó döntés volt, mert így sokkal könnyebb volt kisebb finomításokat végezni, mint ha a stilisztikai definíciók közvetlen a PHP fájlokban található HTML tagokban szerepeltek volna.

A web alkalmazás alapvetõen három részbõl épül fel:

\begin{itemize}
	\item Statikus oldalak
	\item Dinamikus oldalak
	\item Az android alkalmazást ellátó szolgáltatások
\end{itemize}

Statikus oldalnak akkor nevezünk egy weblapot, ha annak a tartalma nem változik. Attól is független, hogy a látogató kicsoda, hanyadszor jelentkezik be vagy hogy honnan jelentkezik be stb..., tehát a tartalom konzisztens minden egyes látogatás alkalmával. Ez a megközelítés fõképp akkor elõnyös ha valami olyan tartalmat akarunk nyújtani a felhasználóknak amin egyáltalán nem áll szándékunkban változtatni, vagy csak nagyon ritkán.

Dinamikus oldalakról akkor beszélünk amikor valamilyen feltétel vagy beavatkozás közvetlenül befolyásolja azt hogy a felhasználó által megtekintett tartalom pontosan micsoda is. Legtöbbször akkor használatos, ha egy adatbázis tartalmát akarjuk megjeleníteni, vagy olyan felületet hozunk létre amely interakciót tesz lehetõvé a felhasználó és a web alkalmazás között. Rengeteg programozás nyelv létezik ennek a célnak az ellátására. Én a PHP-t és a JavaScript-et választottam.

Az android alkalmazást szolgáltatásokkal ellátó rész fõ feladata hogy a szerveren található adatbázishoz elérést biztosítson, mivel android alkalmazások nem tudnak közvetlenül csatlakozni egy távoli adatbázishoz, ezért kell ez a közbülsõ réteg amely kiszolgálja a mobil eszköz kéréseit, illetve olyan tartalmak elérését teszi lehetõvé amelyek közvetlenül valamilyen limitációs okokból nem lennének elérhetõek. Sokszor ezeket egy böngészõbõl megnyitva nem látunk semmit, ez teljesen természetes, mivel itt a hangsúly nem azon van hogy emberek számára értelmezhetõ/olvasható tartalmat biztosítsunk, hanem fõ célunk a web és a mobil alkalmazás közötti kommunikációs csatorna megteremtése, tehát egy olyan környezet ahol csak gépek beszélnek egymással.

\section{Iterációk}

Az oldal megalkotásához egy agilis iterációs dizájn megközelítést alkalmaztam, melyen során egy rövid kezdeti tervezés után elkezdtem a tényleges munkát ami abból állt, hogy implementáltam az adott feladatot, majd az így elkészült munkát tesztelve prezentáltam a megrendelõnek (konzulensnek) A következõ lépés a tesztek során elõkerülõ hibák megbeszélése és azok javításának lehetséges orvosolása valamint az alkalmazás új funkciókkal való bõvítése volt. Ez az utolsó három lépés, tehát az implementálás, tesztelés és hibajavítás valamint további funkciókkal való bõvítés képezte az iterációs dizájn megközelítésem ciklikus magját. Az iterációk során felhasznált eszközökre és technológiák ismertetésére majd csak az iterációs mérföldkövek ismertetése után fogok kitérni. 

\subsection{Elsõ mérföldkõ}Az elsõ mérföldkõ folyamán elõször megbeszéltem a megrendelõvel hogy milyen elvárásokkal rendelkezek illetve vázoltam az általam tervezett munkamenetet. Továbbá kiválasztottam a fejlesztéshez szükséges fejlesztõi környezeteket, valamint ezek és a használatukhoz elengedhetetlen eszközöket elõkészítettem a projekt munkában való felhasználáshoz. Ekkor történt meg a felhasználói felület megjelenési terveinek elkészítése. Webszerver, domain és adatbázis létrehozás illetve telepítés. A kész oldalszerkezeti tervekkel \ref{fig:Wireframe} neki kezdtem a grafikus elemek vizualizációjának valamint implementáltam az oldalszerkezet statikus elemeit mint: Menü rendszer, fejléc, alsó információs sáv, kapcsolatok és egyéb hír csatornák megjelenítésért felelõs elemeket.

\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{Wireframe}
\caption[Elsõ oldalszerkezeti terv]{Elsõ oldalszerkezeti terv \label{fig:Wireframe}}
\end{figure}

\subsection{Második mérföldkõ}A második mérföldkõ során került sor a megrendelõtõl kapott dokumentumok és források feldolgozására majd azok feltöltése a projektbe fõként statikus HTML elemekként. Továbbá végrehajtása a megrendelõ által kért grafikus és szerkezeti változtatásokat mint: Alsó információs sáv átmozgatása és re-faktorizációja egy oldalsó lebegõ mozgó elemmé ($floating sidebar$), menüpontok átnevezése, fejléc logó frissítése, A $borkostolasEredmenyek$ oldal átdolgozása az alábbi módon: Táblázatok kettéválasztása. Vízszintes görgetõ sáv hozzáadása a borok táblázat felsõ és alsó részéhez, melyek együtt mozognak egymással így megoldva a táblázat nagyságából fakadó kezelhetõségi problémát. Az elõre láthatólag bekövetkezõ grafikai felépítés esetleges módosítása könnyítésének érdekében több stílus elemet is újabb osztályokba rendeztem, tehát egy átfogóbb re-faktorizáció történt mely mint késõbb kiderült a további stilisztikai elemek hozzáadását és stilizálását is megkönnyítette.

\subsection{Harmadik mérföldkõ}A harmadik mérföldkõ fõ feladata az azt megelõzõ konzultáció során átbeszélt $demo$ oldal elkészítése volt. Tehát itt került sor a CoHITS algoritmus megismerése a hozzá tartozó szakirodalom áttanulmányozására majd az algoritmus implementálásának megkezdésére a projektbe. Ezt követte a korreláció és átlagtól való átlagos eltérés számolásának implementálása, de mint késõbb kiderült ezek az algoritmusok nem tûrték jól a hiányos bemeneti adatokat ezért végül az általuk generált kimenet nem került felhasználásra. A mérföldkõ végére a CoHITS algoritmus implementálásának befejezése és tesztelése maradt. Ezen mérföldkõ keretén belül ismerkedtem meg a Google grafikonkészítõ API-val, majd azt felhasználtam a CoHITS algoritmus, korreláció és átlagtól való átlagos eltérés adatsorok reprezentációjához.

\subsection{Negyedik mérföldkõ}A negyedik mérföldkõ során egy másik projektbõl\cite{Borkóstolás projekt} származó algoritmusok és azok már kész implementálásának feldolgozása és megismerése volt a fõ feladat. Át kellett tekinteni a kapott kódbázist abból a célból, hogy ezeket is mint majd további opciókat integráljam a rendszerbe. Az említett algoritmusok: Hamming, Koszinusz, Precedencia, Összefüggõségi. De még mielõtt ebbe bele kezdtem, kísérleteztem egy kicsit egy új grafikonrajzoló API (Charts.js) használata mely könnyebben, stílusosabban és személyre szabhatóbban reprezentálja az adatokat. Miután megkaptam a fent említett már implementált algoritmusokat, elkezdtem azokat integrálni az én projektem kódbázisába. Sajnos ez nem ment teljesen gördülékenyen, szükség volt a kapott kódbázisból elõkerülõ implementációs és mûködési problémákkal kapcsolatos kérdések átgondolására valamit konzultálásra ezekkel kapcsolatban, majd a hibák javítása. A sikeres hibaelhárítás és javítások után jött az algoritmusok és demo oldal mûködésének tesztelése.

\subsection{Ötödik mérföldkõ}Az ötödik mérföldkõ bebizonyította, hogy érdemes volt jól megtervezni és szétválasztani az egyes stilisztikai elemeket, mivel a megrendelõ ismét a menü rendszer valamint a fejléc kép ismételt átrendezését és szerkesztését kérte. Továbbá új teszt adatok használatát javasolta a $demo$ menüpontban, amelyek már a friss adatokat tükrözik. Implementálásra került egy visszaigazolást kérõ felhasználói felület mely fõ célja a beviteli mátrix véletlen felülírásának meggátolása volt. Késõbb a bevitel metódus megváltoztatása miatt ennek a funkcionalitása elévült. A korrelációt számoló kód mûködésébõl fakadó hiba ki lett javítva, így már nem állt meg a számolás, ha a kapott hiányos adatsoron nem lehetett egyszerûen korrelációt számolni. Valamint megtörtént a tesztelések során elõkerült további hibák kijavítása is.

\subsection{Hatodik mérföldkõ}A hatodik mérföldkõ vissza hozta a régi grafikonrajzoló API-t (Google charts API), valamint megtörtént a grafikonokat megjelenítõ elemek stilizálásnak egységesítése. Fõ ok a visszaváltásra az volt, hogy az értékeket mint címkéket megjeleníthetõvé tegyük az oszlopok mellett. A borszakértõk személyiségi jogainak védése érdekében a nevük anonimizálásra került. A web alkalmazás új funkciókkal bõvült: Regisztráció, belépés. Ezt követte a $demo$ oldal teljes átdolgozása így már az hozzá kapcsolódik a felhasználói rendszerhez. Ebbõl fakadóan a $demo$ oldal már csak regisztráció illetve bejelentkezés után használható. így a felhasználók a neves borszakértõk által kóstolt borokat saját maguk is tudják értékelni.

\subsection{Hetedik mérföldkõ}A hetedik és egyben utolsó mérföldkõ nagy részét a mobil android alkalmazás elkészítése és tesztelése tette ki, de itt valósult meg az õt kiszolgáló web szolgáltatások implementálása valamint egy alap adminisztrációs felület létrehozása. Legvégül pedig elvégeztem némely kód csinosítást és re-faktorizációt a célból, hogy a kódom könnyebben olvasható és általában véve jobb tetszést keltsen az emberben.

\section{Adatbázis}
Annak ellenére hogy a web oldal legelsõ változata perzisztens adat tárolás nélkül üzemelt és az implementált algoritmus tesztelése részben e nélkül zajlottak, nem jelenti azt hogy a végsõ változatból ez kimaradt volna, vagy esetleg egy nem teljesen kidolgozott adat tároló hierarchiával rendelkezne. Pontosan az ellenkezõje az igaz. Az adatbázis táblák létrahozása elõtt jelentõs idõt fordítottam azok megtervezésére, szem elõtt tartva azt hogy a tervezett alkalmazásoknak milyen igényei lesznek. Az adatbázis relációs sémáját a \ref{fig:dbmodel} ábra ábrázolja. Fontos még megemlíteni, hogy az adatbázis összes táblája $utf8\_unicode\_ci$ alapértelmezett karakter kódolást alkalmaz, mely biztosítja, hogy többek közt a Magyar nyelvi sajátos karakteri is megfelelõen tárolódjanak.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth]{../../Borkostolas_weblap/dbmodel}
	\caption[Adatbázis model]{Adatbázis model \label{fig:dbmodel}}
\end{figure}

Az adatbázist kiszolgáló szervernek az Oracle által fejlesztett MySQL-t választottam. Ezt ismerem a legjobban, valamint az sem elhanyagolható, hogy nyílt forráskódú talán ezért is rengeteg web szolgáltató által nagyon kedvelt gyakran alkalmazott megoldás. 

\subsection{scores tábla}

Ahogy az értékeléseket tartalmazó $scores$ táblát létrehozó szkript  \ref{lst:scores create} kód részlet is tükrözi, látható, hogy a táblában a felhasználók azonosítóját $user\_id$ tartalmazó oszlop és a borok azonosítóját $wine\_id$ tartalmazó oszlop is mint $FOREIGN\_KEY$ szerepel amik természetesen a borokat $wines$ és a felhasználókat $users$ tartalmazó táblák megfelelõ oszlopaira hivatkoznak, ezek segítik az adatbázis konzisztenciájának megõrzését, mivel amikor egy felhasználó vagy bor törlésre kerül akkor az $ON\ DELETE\ CASCADE$ megkötés hatására az értékeléseket tartalmazó $scores$ táblából azok a sorok is törlõdni fognak amik így már nem létezõ azonosítókra hivatkoznának. Itt talán még érdemes kitérni arra is hogy takarékossági okokból az értékelések maximum nyolc számjegybõl állhatnak amiben a decimális pontosságot három tizedes jegyig engedélyezzük. 

\begin{minipage}{\linewidth}
\begin{lstlisting}[language=sql,label={lst:scores create}, caption={Az értékeléseket tartalmazó ($scores$) táblát létrehozó parancs}]
CREATE TABLE IF NOT EXISTS `scores` (
`user_id` int(11) DEFAULT NULL COMMENT 'user''s id',
`wine_id` int(11) DEFAULT NULL COMMENT 'wines''s id',
`score` decimal(8,3) DEFAULT NULL COMMENT 'score given by the user_id user for the wine_id wine',
`timestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
FOREIGN KEY (`user_id`) REFERENCES users(`user_id`) ON DELETE CASCADE,
FOREIGN KEY (`wine_id`) REFERENCES wines(`wine_id`) ON DELETE CASCADE
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci COMMENT='score data';
\end{lstlisting}
\end{minipage}

Valamint az is jól látható hogy egy idõbélyeg oszlopban $timestamp$ nyomon követjük majd az értékelések módosításának idõpontját, ez elengedhetetlen a web és android alkalmazás között való effektív szinkronizációhoz. Végül talán még érdemes arra kitérni hogy melyik mezõ milyen értéket vehet föl és mik azok alapértelmezett értékei: a $user\_id$ és a $wine\_id$ helyzetét már tisztáztuk, nem maradt más mint az értékeléseket tartalmazó $score$ és a módosítások idõbélyegét nyomon követõ $timestamp$. A $score$ mezõ értéke akár $NULL$ is lehet így lehetõvé téve a felhasználók számára hogy ha esetleg meggondolták magukat akkor töröljék a már meglévõ értékelésüket. Ez lényegében csak egy praktikus megoldás mert így amikor az alkalmazás egyszerre több értékelés eredményét próbálja módosítani akkor azt meg tudja tenni egy $UPDATE$ SQL paranccsal, nem kell ennek az esetnek a külön kezelésére egy $DELETE$ utasítást írni. Valóban így több hely foglalódik le az adatbázisban, de ne felejtsük el, hogy olyan borok értékelésérõl beszélünk amiket az adott felhasználó egyszer már értékelt. Én valószínûbbnek tartom azt hogy valaki a kitörölt bort késõbb újra értékel mint az hogy soha többet nem tér vissza hozzá. A $timestamp$ mezõ alapértelmezett értéke a $CURRENT\_TIMESTAMP$ ami másodperc pontossággal tartalmazza az idõt alábbi formátumban: $Y-m-d\ h:i:s$ ahol $Y$ az év $m$ a hónap $d$ a nap mindegyik numerikus, majd $h$ az óra $i$ a perc és $s$ a másodperc két karakteres formátumban. $NULL$ helyett pedig $0000-00-00 00:00:00$ fog szerepelni a mezõben.

\subsection{wines tábla}

A borokat tartalmazó $wines$ tábla egyáltalán nem bonyolult. A tábla indexelését a $wine\_id$ segítségével történek amely minden egyes új bor hozzáadásánál automatikusan növekszik eggyel az $AUTO\_INCREMENT$ -nek köszönhetõen. Az évjáratot $wine\_year$ és az árat $wine\_price$ tartalmazó mezõkön kívül az összes többi megadása kötelezõ. Az évjárat egy maximum négy jegyû egész szám lehet, míg az ára akár hatvannégy hússzú is lehet. Jelenleg a borok ára Magyar Forintban értendõ. Ezek a megkötések fõképp a projekt fejlesztése alatt megismert borkóstolási versenyek és adatbázisok szerkezeti felépítése miatt lettek így meghatározva. A többi mezõ kötelezõ szöveggel való feltöltését az alábbi táblázat \ref{tbl:wines-content} határozza meg:

\begin{table}[h!]
\begin{center}
\begin{tabular}{| l | l |}
	\hline
	\textbf{Mezõ} & \textbf{Tartalom} \\ \hline
	wine\_name & A bor neve \\ \hline
	wine\_winery & A pincészet neve \\ \hline
	wine\_location & A bor származási helye \\ \hline
	wine\_composition & A bor összetétele \\ \hline
\end{tabular}
\end{center}
\caption{A borokat leíró tábla kötelezõ mezõinek felépítése \label{tbl:wines-content}}
\end{table}

\subsection{users tábla}

A felhasználókra vonatkozó adatokat nyomon követõ tábla neve az adatbázisban $users$. A tábla elsõre talán túl bonyolultnak tûnhet, de minden mezõnek fontos feladata van, melyek lehetõvé teszik egy kedvelt felhasználó kezelõ modul használatát \cite{php-login}. A borokat tároló $wines$ táblához hasonlóan itt is van egy azonosító még pedig a $user\_id$ amely a tábla indexelését látja el és automatikusan növekszik eggyel az $AUTO\_INCREMENT$ -nek köszönhetõen amikor egy új felhasználó regisztrál a rendszerbe. A $user\_id$ nem az egyetlen egyedi $UNIQUE$ azonosító a táblában, a felhasználó nevét tároló $user\_name$, valamint a regisztrált felhasználó által megadott e-mail címet tároló $user\_email$ mezõ is egyedi ezzel azt meggátolva, hogy valaki már egy létezõ e-mail címmel vagy felhasználó névvel újból regisztráljon. Ezek voltak a regisztráció során kötelezõen megadandó mezõk egy része, persze késõbb még szó lesz a jelszó kezelésrõl is. A regisztráció után már aktivált felhasználó státuszt a $user\_active$ követi nyom, úgy hogy azokhoz akik még nem látogatták meg a regisztrációt visszaigazoló e-mailben kapott linket, hozzájuk nullát rendel, akik pedig ezt már megetették egyet kapnak, ez arra szolgál hogy csak olyan e-mail címeket zároljon a rendszer amelyek már regisztráció után aktivált felhasználó fiókhoz tartoznak. A felhasználót azonosító süti kulcs a $user\_rememberme\_token$ mezõben tárolódik, mely két hétig érvényes, ezzel lehetõvé téve a web alkalmazás számára, hogy felismerje az ismételt látogatókat még akkor is ha már más $HttpSession$ be tartoznak. A hibás bejelentkezések számát a $user\_failed\_logins$ mezõ tárolja, többek között ennek pontos felhasználását késõbb fogom részletezni a felhasználó kezelõ rendszer részletes ismertetésénél. A regisztráció során használt ip cím a $user\_registration\_ip$ -ben tárolódik el. Adminisztrátori jogosultság megadását teszi lehetõvé a $user\_permission$ mezõ, melynek alapértelmezett értéke $0$, $1$ pedig az adminisztrátori jogosultságot szimbolizálja. A még nem tárgyalt mezõket két csoportra bonthatjuk, az egyik mely valamilyen hash stringet tartalmaznak mint a $user\_password\_hash$, $user\_activation\_hash$, $user\_password_reset\_hash$. A másik csoport pedig olyan mezõk amelyek valamilyen tevékenységet nyomon követõ idõ bélyeget tárolnak mint a: $user\_password\_reset\_timestamp$, $user\_last\_failed\_login$, $user\_registration\_datetime$. Nézzük elõször az utóbbit, az idõ bélyeg típust tároló mezõket. A $user\_password\_reset\_timestamp$ arra szolgál hogy nyomon tudjuk követni, hogy a felhasználó vagy esetleges támadó mikor igényelt jelszó újra beállító e-mailt. A $user\_last\_failed\_login$ mezõ a legutolsó hibás bejelentkezés idõpontját tárolja. A $user\_registration\_datetime$ -ben tárolt idõpontra pedig majd a regisztrációt visszaigazoló és aktiváló e-mail linkjének kezelésekor lesz szükség. Végül röviden azokról a mezõ típusokról amelyek valamilyen hash stringet tárolnak, mivel arra, hogy mi a hash és miért de fõképp milyen módon van használva, majd többek között késõbb térek ki a felhasználó kezelõ rendszer részletes ismertetésénél. A $user\_password\_hash$ tárolja a felhasználó jelszavát hashelt formátumban. A regisztráció után küldött aktivációs e-mailhez használt aktivációs link validitásának ellenõrzésére szolgáló hasht a  $user\_activation\_hash$ tárolja. $user\_password_reset\_hash$ pedig az új jelszót igénylõ e-mail link hitelesítésére használt hasht tárolja.

\section{CSS}
CSS avagy \textbf{C}ascading \textbf{S}tyle \textbf{S}heets egy stilisztikai leíró nyelv melynek célja hogy leírja miképp formázódjanak és jelenjenek meg egy dokumentum elemei amelyeket egy markup nyelven írtak. Markup nyelvnek nevezzük az olyan nyelveket melyek szintaktikailag megkülönböztethetõek a dokumentum szövegétõl, jelenes esetben ez a HTML, mely elõre definiált prezentációs sémákkal rendelkezik, ami azt jelenti hogy egy adott specifikáció adja meg, hogy az adatokat milyen módon jelenítse meg a rendszer. 

A CSS-t elõször Hakon Wium Lie terjesztette elõ 1994 Októbar 10. -én \cite{CSS-origin} a weblapok stílusát leíró nyelvként a W3C (World Wide Web Consortium, a világháló szabványaiért felelõs nemzetközi szervezet) publikus levelezõlistáján. A CSS 1 specifikációja elkészültekor még nem volt olyan böngészõ amely teljesen támogatta volna azt. Két évvel késõbb a CSS 2 többek között bemutatta elemek abszolút, relatív és fixált pozicionálását, valamint bevezette a z tengely mentén való indexelés lehetõségét. A CSS 3 tól nem beszélhetünk W3C által elfogadott szabványról, ez a verzió fõképp abban tér el elõdjeitõl, hogy egy moduláris felépítést követ. Minden modul kiterjeszti valamilyen módon, vagy új képességekkel látja el a korábbi CSS 2 -es funkciókat, ezzel megõrizve a visszafelé kompatibilitást. 

Tagadhatatlan, hogy a CSS a webfejlesztés egyik fõ sarokköve. Létrehozásának fõ oka az volt, hogy a HTML oldalak tartalmi illetve prezentációs része könnyen szétválasztható legyen. Ez a szeparáció azért is fontos, mert így nagyobb flexibilitást nyerhetünk a prezentáció területén, valamint lehetõvé válik a HTML oldalak formázottságának megosztása egy egységes CSS fájlnak köszönhetõen. Ezzel csökken a tartalmi oldalak komplexitása, valamint kevesebb lesz bennük az ismétlõdés. Elõnyök között mindenképpen említésre méltó, hogy így könnyebben lehetséges ugyan azt a markup nyelv által leírt dokumentumot több különbözõ stílusban megjeleníteni attól függõen, hogy kinek, illetve milyen célra szánt az adott tartalom. Pontosabban ez alatt azt értjük hogy a megjelenítés különbözõ lehet akár egy képernyõn, nyomtatásban, hangosan (képernyõ felolvasáskor) vagy Braille billentyûs eszközökön. Továbbá az is lehetséges, hogy a megjelenítendõ tartalmat illeszkedjen az adott eszköz képernyõ méretéhez.

Számomra mint már korábban említettem a CSS fõ elõnye az volt, hogy a web alkalmazás stilisztikai felépítést egy fájlból könnyedén tudtam módosítani. De sajnos nem csak elõnye vannak a CSS használatának. Az ember könnyen bele tud futni néhány igen bosszantó limitációba, mint például elemek vertikális rendezése. Míg a vízszintes elrendezés általánosságban könnyen kezelhetõ, a vertikális sokszor nem túl intuitív módon valósítható csak meg, ha egyáltalán megvalósítható. Egyszerû feladatok mint például egy elem vertikálisan való középre zárása, vagy a lábléc limitálása hogy ne legyen magasabb mint a viewport alja, vagy nem intuitív komplikált szabályrendszert igényel, vagy olyan szabályokat igényel melyek nem túl bonyolultak viszont kevéssé támogatottak. Viszont az kétségtelen, hogy használatának elõnyei túlnyomó részben vannak hátrányaihoz képest. Némelyikbe azért konkrétan én is bele futottam és jelentõs kísérletezgetésbe telt mire sikerült olyan szabályrendszert alkotni a leíró nyelvben mely a számomra elfogadható megjelenítést tette lehetõvé. A kulcs az volt hogy minden fõ elemet egy konténerbe kellett tegyek amelyek egy $clear:both;$ tulajdonsággal rendelkeznek majd ezeken belül már könnyebben tudtam pozicionálni a további elemeket. Ennek megértéséhez azt kell tudni, hogy a CSS -ben három fõ pozicionálási mód van. 

\paragraph{Normal flow}Az $inline$ elemek úgy vannak elrendezve mint a betûk egy szavakat tartalmazó szövegben, tehát egymás után a rendelkezésre álló területen amíg van szabad hely, ha elfogy a hely akkor egy új sorban folytatódnak. $Block$ elemek vertikálisan rakhatók össze, mint a paragrafusok vagy mint a felsorolások egyes pontjai. A $normal flow$ lehetõvé teszi $inline$ elemek vagy $blokkok$ relatív pozicionálást.

\paragraph{Flaot} Egy lebegõ elem kikerül a $normal\ flow$-ból és balra vagy jobbra igazodik amennyire csak lehet a rendelkezésre álló szabad területen. A többi tartalom majd ennek az oldalán lebeg.

\paragraph{Absolute positioning}Egy abszolút módon elhelyezett elem nem foglal helyet és nincs hatással a $normal flow$ típusú elemekre. Egy maghatározott saját területet foglal el a konténerében a többi elemtõl függetlenül.

\paragraph{Position}Nem meglepõ módon négy pozíció van: $top$ - fel, $bottom$ - le, $left$ - balra, $right$ - jobbra. Ugyan csak négy lehetséges értéke lehet a $positio$ tulajdonságnak. Amennyiben egy elem $static$ -tól eltérõ módon van elhelyezve akkor a további tulajdonságok $top$, $bottom$, $left$, $right$ eltolás illetve pozíció definiálásra szolgálnak. A négy lehetséges érték:

\begin{enumerate}
\item\textbf{Static}: Az alapértelmezett érték amely a $normal\ flow$ -ba teszi
\item\textbf{Relative}: Az elem a $normal\ flow$ -ba kerül majd abból a pozícióból eltolódik. A további elemel úgy kerülnek elrendezésre mint ha az eredeti elem ott maradt volna.
\item\textbf{Absolute}: Abszolút pozicionálást definiál. Az eleme a legközelebb nem $static$ elemû õséhez képest lesz pozicionálva.
\item\textbf{Fixed}: Az elem abszolút pozicionálásra kerül egy fixált pozícióban a képernyõn még akkor is ha az egész dokumentum el van görgetve. az elemet	
\end{enumerate}

\paragraph{Float és clear}A $float$ tulajdonságnak három különbözõ értéke lehet. Abszolút vagy fixen pozicionált elemek nem lehetnek $float$ típusúak. Más elemek normálisan lebegnek a többi $float$ típusú elem körül, hacsak azt az $clear$ tulajdonságuk meg nem gátolja.
\begin{enumerate}
	\item\textbf{left}: Az elem annak a vonalnak a bal oldalán jelenik meg ahol eredetileg jelent volna meg, a többi elem a jobb oldalán lesz.
	\item\textbf{right}: Az elem annak a vonalnak a jobb oldalán jelenik meg ahol eredetileg jelent volna meg, a többi elem a bal oldalán lesz.
	\item\textbf{clear}: Arra kényszerít egy elemet hogy az $clear$ által meghatározott elem bal oldalán legyen $clear:left$ vagy jobb oldalán $claer:right$ vagy esetleg mindkét oldalán $clear:both$.
\end{enumerate}

Kellõ kísérletezés és gyakorlás után azért elérhetõ egy olyan struktúra amely ezeket megfelelõen egymásba ágyazva a kívánt kinézetet nyújtja. 

Érdemes még azért a CSS szintaktikájával is tisztában lenni. Röviden egy CSS szabály egy $selector$-ból és egy deklarációs blokkból épül fel.

\begin{minipage}{\linewidth}
	\begin{lstlisting}[language=html,label={lst:css syntax}, caption={CSS szintaxis}]
	h2 {color: #bb1f42; font-size: 1.2em;}
	\end{lstlisting}
\end{minipage}

Konkrétan a \ref{lst:css syntax} kód részletben látott CSS kódnál a $h2$ a $selector$ õt követi a deklarációs blokk amely két deklarációt tartalmaz. Egy deklarációnak két része van, egy a tulajdonságot megnevezõ része, ez van a $:$ elõtt, és egy azt követõ rész amely az értéket tartalmazza. Lehetséges még több $selector$ összecsoportosítsa, melynek köszönhetõen jócskán csökkenthetõ az ismétlõdõ kód. Ugyan ezt segíti elõ az is, hogy a CSS alapvetõen támogat öröklõdést, így egy felsõ konténeren definiált tulajdonság mindig lefelé a gyermekei felé propagál. Természetes a kevesebb kódnak más jó mellékhatása is van, mint a gyorsabban töltõdõ weboldal és kisebb sávszélesség használat. A $selector$ több típusú is lehet és ezeket kombinálni is lehet. A \ref{lst:css syntax} kód részletben látottat $element selector$ -nak hívják, mely egy adott típusú elemet választ ki. A $class selector$ az olyan elemekre fog vonatkozni amik az adott $class$ attribútummal rendelkeznek. Ilyenkor egy pontot teszünk a $selector$ elé. Némely elem rendelkezhet különbözõ típusokkal is, pl.: egy $checkbox$ típusú $input$ elemre a $selector$ az alábbi módon nézne ki: $input[type=checkbox]$.

\section{PHP}
A PHP ($PHP:\ Hypertext\ Preprocessor$) egy széles körben elterjedt nyílt forráskódú általános célokra kifejlesztett szkript nyelv amely különösképpen alkalmas webes fejlesztésre, valamint HTML -be ágyazható. Ezt az alábbi példa \ref{lst:php hello world} kód részlet szemlélteti.
\begin{minipage}{\linewidth}
	\begin{lstlisting}[language=html,label={lst:php hello world}, caption={PHP Hello World!}]
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
	<title>Példa</title>
	</head>
	<body>
		<?php
			echo "Hello Világ!";
		?>	
	</body>
</html>
	\end{lstlisting}
\end{minipage}
A PHP kód egy különleges nyitó és záró $<?php\ ?>$ struktúrában helyezkedik el, ezzel lehetõvé téve, hogy ki és be lépjünk a PHP-ba. A PHP-t azt különbözteti meg a kliens oldali szkriptektõl mint például a JavaScript, hogy a kód a szerver oldalon hajtódik végre, itt generálódik a HTML tartalom melyet majd a webszerver küld a kliensnek. Az is megoldható, hogy egy webszervert úgy konfiguráljunk, hogy az a PHP-t tartalmazó HTML fájlokat is dolgozza fel. Ekkor a felhasználó nem fogja megtudni, hogy mi neki most éppen egy PHP által generált tartalmat mutatunk.

Annak ellenére, hogy a PHP egy szkript nyelv robusztus alkalmazások létrehozására is használható, erre kiváló példa többek között a Facebook vagy akár a Wikipedia. Személy szerint ez elõtt nem sokat foglalkoztam a PHP -val csak kisebb weboldalak létrehozására használtam, nem igazán követtem nyomon a nyelv fejlõdését mely eredetileg a PHP/FI névvel lett létrehozva 1994 -ben Rasmus Lerdorf által. Ez az elsõ változat egy egyszerû Common Gateway Interface (CGI) bináris állomány volt a C programozási nyelven írva melynek fõ feladata az õ személyes honlapjának egy eszköze volt. Ez már nagyon régen volt és a nyelv rengeteg változtatáson és javításon esett át. Most már a PHP 5. verziójánál tartunk. Én is ezt a verziót használtam, mely 2004 -ben lett kiadva. Fõ vezérlõ magja a $Zend\ Engine\ 2.0$ amely egy tucatnyi új szolgáltatás között egy új objektum modellt is tartalmaz. Jelenleg több tucatnyi fejlesztõ dolgozik a PHP továbbfejlesztésével mely továbbá pár tucat másik fejlesztõnek ad munkát akinek a feladata a PHP -hez kapcsolódó támogató projektek fejlesztése és dokumentálása. Ez csak egy korábbi éveken alapuló becslés, de nyugodtan mondhatjuk, hogy a PHP több tíz vagy akár száz millió domain-re van telepítve világszerte \cite{php-history}.

A PHP nyelv általános felépítésére és szintaxisára nem térek ki, egyrészt azért mert már egy elég régi nyelv melynek alapjai régóta ismertek, valamint azért is mert elég közel a $C$ nyelvhez, mely még ismertebb. Viszont mindenképpen ejtenék pár szót a nyelv sajátosságáról fõkép arra fókuszálva, hogy hogyan történik az állapotkövetés illetve adatbázis elérés.

\subsection{PHP Data Objects (PDO)}
A PHP Data Objects (PDO) a PHP adatbázis elérést nyújtó interfésze. Minden adatbázis meghajtó amely implementál egy PDO interfészt elérhetõvé tehet az adott adatbázisra specifikus funkciókat. Természetesen önmagában a PDO alkalmatlan adatbázis kezelésre, mindenképpen egy konkrét adatbázis meghajtót kell használni. Mivel a web alkalmazást egy $MySQL$ adatbázis szerver szolgálja ki ezért én a hozzá tartozó $PDO\_MYSQL$-t használtam. A PDO alapértelmezetten együtt jár a PHP 5.1-el és elérhetõ PECL kiterjesztésként is PHP 5.0 alatt, de mivel a PDO -nak szükségen van PHP 5 magjában bemutatott objektum orientáltságra, ezért a PDO nem fut korábbi PHP verziókon. 

\begin{minipage}{\linewidth}
	\begin{lstlisting}[language=php,label={lst:php pdo connection}, caption={PHP PDO Connector használata}]
private function databaseConnection()
{
	// if connection already exists
	if ($this->db_connection != null) {
		return true;
	} else {
	try {
		$this->db_connection = new PDO('mysql:host='. DB_HOST .';dbname='. DB_NAME . ';charset=utf8', DB_USER, DB_PASS);
		return true;
	} catch (PDOException $e) {
	$this->errors[] = MESSAGE_DATABASE_ERROR . $e->getMessage();
}
}
// default return
return false;
}
	\end{lstlisting}
\end{minipage}

A \ref{lst:php pdo connection} kódrészlet a bejelentkeztetõ modul egyik metódusán keresztül mutatja be, hogy hogyan lehet a PHP PDO -vel adatbázis kapcsolatot létrehozni. Elõször is ellenõrzésre kerül, hogy létezik -e már felépített adatbázis kapcsolat, nyilván ha már igen akkor nincs mit tenni, de ha még nem, akkor létrehozunk egy új PDO objektumot, úgy hogy a konstruktorának átadjuk az adatbázis címét, nevét, azt a felhasználót amelyikkel csatlakozni szeretnénk és természetesen a hozzá tartozó jelszót. Ezek a kódrészletben sorra a $DB\_HOST$, $DB\_NAME$, $DB\_USER$, $DB\_PASS$ melyek egy külön konfigurációs fájlban kerültek definiálásra. Itt fontos még megemlíteni, hogy az adatbázis nevének megadásakor egyben megadjuk a karakter kódolást is, mivel ennek elhanyagolása biztonsági problémákat okozhat \cite{PDO-charset-security}. Természetesen a kódunknak készen kell állni esetleges nem várt események bekövetkezésére, ezért mind ez egy $try\ - catch$ blokkban zajlik le, a remélhetõleg nem fellépõ hibaüzeneteket pedig egy az azok tárolására létrehozott tömbben tároljuk, amibõl majd késõbb könnyen ki olvashatók, ha esetleg értesíteni akarunk valakit róluk.

Az adatbázis kapcsolatot nagyon egyszerû bezárni ahogy a \ref{lst:php pdo close connection} kódrészlet is mutatja. Ez nagyon fontos is, hogy mindig bezárjuk miután befejeztük a használatát, mivel sok szolgáltató limitálja, hogy hány aktív kapcsolatot kezel az adatbázis szerverük.

\begin{minipage}{\linewidth}
	\begin{lstlisting}[language=php,label={lst:php pdo close connection}, caption={PHP PDO kapcsolat lezárása}]
	db_connection = null;
	\end{lstlisting}
\end{minipage}

Miután sikeresen létre hoztunk egy aktív adatbázis kapcsolatot SQL utasításokat a \ref{lst:php pdo sql query} kódrészletben látott módon indíthatunk. A példában éppen lekérjük egy felhasználó összes információját, majd az így kapott információkat egy objektumban adja vissza a $fetchObject\left(\right)$ metódus. Tehát például a $user\_id$ a \ref{lst:php pdo result handling} kódrészletben látottak szerint lesz elérhetõ. Használatos még többek között a $fetchAll\left(\right)$ ami az SQL lekérdezés által visszaadott összes sort egy egy tömbben adja vissza. Hasznos lehet még ismerni a $rowCount\left(\right)$ metódust, ami megadja az SQL parancs által érintett sorok számát.

\begin{minipage}{\linewidth}
	\begin{lstlisting}[language=php,label={lst:php pdo result handling}, caption={PHP PDO eredmény kezelés}]
	$user_id = $result_row->user_id;
	\end{lstlisting}
\end{minipage}

Vegyük észre, hogy az SQL lekérdezésbe nem konkatenáljuk bele a változókat, ha ilyesmit tennénk akkor az alkalmazásunkat nagyon könnyen feltörhetnék, hiszen éppen ilyen programozói hibákat kihasználva mûködnek az $sql injection$ jellegû támadások. Tehát ha változókat akarunk használni az SQL lekérdezésünkben, akkor a $prepare\left(\right)$ metódusban a behelyettesítendõ helyre kettõsponttal megelõzött változónevet kell írni, melyet majd a $bindValue\left(\right)$ metódussal fogunk ténylegesen a mi változónkhoz kötni. Ez elsõ paraméterként egy stringet vár, ami az SQL lekérdezésben szereplõ változó helyét határozza meg. A második paramétere a mi PHP változónk aminek az értékét az SQL parancsban szeretnénk használni. A harmadik és egyben utolsó na meg opcionális paraméter pedig az elsõ paraméterre vonatkozóan definiálja annak adat típusát. Az $execute\left(\right)$ -hez nem kell sokat hozzáfûzni, egyszerûen végre hajtja a fentiek szerint elõkészített SQL parancsot.

\begin{minipage}{\linewidth}
	\begin{lstlisting}[language=php,label={lst:php pdo sql query}, caption={PHP PDO SQL lekérdezés}]
	$query_user = $this->db_connection->prepare('SELECT * FROM users WHERE user_name = :user_name');
	$query_user->bindValue(':user_name', $user_name, PDO::PARAM_STR);
	$query_user->execute();
	$result_row = $query_user->fetchObject();
	\end{lstlisting}
\end{minipage}

\subsection{Állapotkezelés}
A PHP nyelveben az állapotkezelésnek két fõbb fajtáját használtam. 

\todo session post/get/request

\section{JavaScript}
\subsection{numeric}
http://numericjs.com/lib/numeric-1.2.6.min.js

\section{JQuery}

\section{Grafikonok}
\subsection{Google Charts}

\section{Statikus tartalom}
\subsection{index.php - Fõoldal}
\subsection{borkostolasEredmenyek.php - Eredmények}
\subsection{modszerek.php - Módszerek}
\subsection{kapcsolat.php - Kapcsolat}

\section{Dinamikus tartalom}
\subsection{php-login}
\paragraph{Hashelés}
A hashelés
\paragraph{Felhasználói állapot nyomkövetése}
Nyomkövetés
\subsection{demo.php - Demó}


\chapter{A mobil alkalmazás}
Android alkalmazás fejlesztés

\section{Android}
Android
\todo MVC
\todo android register, passwordReset 
\todo talk about threading UI/new thread mi futhat hol és mi nem
\todo távoli adatbázis elérés
\todo local SQLLite adatbázis
\todo lokális változok kezelése SQL/properties vagy mifene

\chapter{A weboldal és a mobil alkalmazás összefûzése}
A weboldal és a mobil alkalmazás összefûzése

\chapter{Tesztelés}
\section{Regisztrációs és bejelentkeztetõ rendszer}
\section{Demo adatkezelésének ellenõrzése}
\section{Algoritmusok ellenõrzése kis adatokon}
\section{Algoritmusok ellenõrzése ismert eredményekkel}
\todo mellékelni az excel filet és arra hivatkozni, valamint az oldal kezdetleges verziójáról egy kép

\chapter{Összefoglalás}

\chapter{Egyebek}
\section{Verziókezelés}

\subsection*{Verziókezelés röviden}
Ez alatt több verzióval rendelkezõ adatok kezelését értjük. Leggyakrabban a szoftverfejlesztésben használnak verziókezelõ rendszereket fejlesztés alatt álló dokumentumok, tervek, forráskódok és egyéb olyan adatok verzióinak kezelésére, amelyeken több ember dolgozik egyidejûleg vagy amelyen több fizikai helyrõl dolgoznak.

\subsection{Git}
A \textbf{Git} egy nyílt forráskódú, elosztott verziókezelõ szoftver, amely a sebességre helyezi a hangsúlyt melyet eredetileg Linus Torvalds fejlesztette ki a Linux kernel fejlesztéséhez. Az elosztottság abban valósul meg, hogy a Git minden fejlesztõ helyi munkaváltozatában rendelkezésre bocsátja a teljes addigi fejlesztési történetet, és a változtatások másolása mindig két repository között történik. Ezeket a változtatásokat mint külön ágakat importálják és összefésülhetõek, hasonlóan a helyben létrehozott fejlesztési ágakhoz. Ez azért jó, mert így minden munkamásolat egy teljes értékû repository teljes verziótörténettel és teljes revíziókövetési lehetõséggel, amely nem függ a hálózat elérésétõl vagy központi szervertõl.

\subsection{GitHub}
A GitHubot eredetileg Tom Preston-Werner, Chris Wanstrath és PJ Hyett hozta létre a kódmegosztási procedúra szimplifikálásának érdekében, mára a világ legnagyobb kód távoli kód repository szolgáltatójává nõtt \cite{Github}.

\subsection{A választás} Már a kezdetektõl nyilvánvaló volt számomra, hogy valamilyen verziókezelõ rendszer használata elengedhetetlen lesz, mivel gyakran nem csak egy specifikus munkaállomásról szoktam dolgozni. Ez nem csak azért jó, mert nagyobb flexibilitást nyújt térben és idõben, hanem azért is mert valamilyen szinten szimulálja azt amikor valaki egy projekt munkában egy közös kódbázison dolgozik. Korábbi munkáim és tanulmányaim során már néhány ilyen rendszerrel is megismerkedtem, többek között SVN, Git, Mercurial. A szakdolgozathoz tartozó alkalmazások készítéséhet végül a Git -et választottam mint verziókezelõ rendszer, melyhez távoli repository szolgáltatónak a GitHub társult. A választás fõ támpontjai között talán a felhasználó barátságot és könnyû automatizálhatóságot említeném meg. 

\subsection{Repozitóriumok}
A szakdolgozat, web és android alkalmazás forráskódja az alábbi linkeken érhetõk el:

\begin{itemize}
\item Szakdolgozat: 
\url{https://github.com/TomVarga/borkostolas_szakdolgozat}
\item Web alkalmazás: \url{https://github.com/TomVarga/borkostolas_web_interface}
\item Android alkalmazás: \url{https://github.com/TomVarga/borkostolas_android_app}
\end{itemize}


\section{Környezetek}
SublimeText - linterek

PhpStorm

Android Studio


%\begin{tét}
%\label{tét-alap}
%Ez itt egy tétel.
%\end{tét}

%%A bizonyítás \begin{proof} és \end{proof} közé kerül:
%\begin{proof}
%Ez pedig a bizonyítása, melyben szerepel egy képlet:
%\begin{equation}
%\begin{split}
%E^{\text{globális}} &= \text{tét}_1\cdot E_1^{\text{elemi}}+\text{tét}_2\cdot
%E_2^{\text{elemi}}+\ldots+\text{tét}_n\cdot E_n^{elemi} \\
%&=E^{\text{elemi}}\left(\text{tét}_1+\text{tét}_2+\ldots+\text{tét}_n\right)\\
%&=E^{\text{elemi}}\cdot\text{össztét}
%\end{split}
%\end{equation}
%A második egyenlõségnél azt használtunk ki, hogy ...
%
%Ezzel a bizonyítást befejeztük.
%\end{proof}

%\begin{defi}
%\label{def-pelda}
%Ez egy definíció. Számozása a tételekkel együtt történik.
%\end{defi}

%\begin{áll}
%A követekezõ négy állítás egymással ekvivalens:
%\label{áll-ekvivalencia}
%  \begin{itemize}
%  \item[(i)] $M$ és $N$ gyengén ekvivalensek.
%  \item[(ii)] Minden $n$
%  nemnegatív egész számra $|L_{M}\cap \Sigma_{1}^{n}|=|L_{N}\cap \Sigma_{2}^{n}|$ teljesül.
%  \item[(iii)] Minden $n$ nemnegatív egész szám esetén
%   létezik
%  $ \pi_{n}: L_{M}\cap \Sigma_{1}^{n} \rightarrow L_{N}\cap \Sigma_{2}^{n} $ kölcsönösen egyértelmû
%  leképezés.
%  \item[(iv)] Minden nemnegatív $n$-re $x A^{n} y^{T}=x' A'^{n} y'^{T}$.
%  \end{itemize}
%\end{áll}

%\begin{köv}
%  Ez pedig egy következmény.
%\end{köv}

%\begin{pld}
%  Ez lesz a példa, ezt nem szedjük dõlten.
%\end{pld}

%\begin{megj}
%  A fejezetet pedig egy megjegyzés zárja.
%\end{megj}


%\section{Listák}
%
%Ez egy felsorolás:
%\begin{itemize}
%    \item elsõ
%    \item második
%      \subitem elsõ
%      \subitem második
%    \item harmadik
%    \item[$\clubsuit$]  saját jel is alkalmazható
%\end{itemize}
%Ez pedig egy számozott lista:
%\begin{enumerate}
%            \item hétfõ
%            \item kedd
%            \item szerda
%\end{enumerate}

%Oldaltörést is alkalmazhatunk
\pagebreak


%\section{Egy táblázat és egy ábra}
%
%A táblázat itt következik.
%\begin{table}[!h]\label{strategia}
%\caption{Példa stratégiatáblára a Black Jack esetében}
%\begin{center}
%\begin{tabular}{l||r|r|r|r|r|r|r|r|r|r}
%&ász&2&3&4&5&6&7&8&9&10\\
%\hline\hline
%21&n&n&n&n&n&n&n&n&n&n\\
%20&n&n&n&n&n&n&n&n&n&n\\
%19&n&n&n&n&n&n&n&n&n&n\\
%18&n&n&n&n&n&n&n&n&n&n\\
%17&n&n&n&n&n&n&n&n&n&n\\
%16&h&n&n&n&n&n&h&h&b&b\\
%15&h&n&n&n&n&n&h&h&h&b\\
%14&h&n&n&n&n&n&h&h&h&b\\
%13&h&n&n&n&n&n&h&h&h&h\\
%12&h&n&n&n&n&n&h&h&h&h\\
%11&h&D&D&D&D&D&D&D&D&h\\
%\end{tabular}
%\end{center}
%\end{table}
%
% % %%Lássunk egy ábrát is!
%\begin{figure}[!h]
%\unitlength 8mm
%\begin{center}
%\begin{picture}(8,6)
%\thicklines
%\multiput(0,1)(0,1){2}{\line(1,0){5}}
%\multiput(3,0)(1,0){2}{\line(0,1){6}}
%\multiput(1,0)(1,0){2}{\line(0,1){1}}
%\multiput(6,0)(1,0){2}{\line(0,1){5}}
%\multiput(0,1)(1,0){3}{\line(0,1){1}}
%\multiput(2,4)(3,0){3}{\line(0,1){1}}
%\multiput(3,0)(0,3){3}{\line(1,0){1}}
%\multiput(6,0)(0,1){4}{\line(1,0){1}}
%\multiput(7,2)(0,1){2}{\line(1,0){1}}
%\multiput(2,4)(0,1){2}{\line(1,0){6}}
%\put(5,1){\line(0,1){1}}
%\put(8,2){\line(0,1){1}}
%\put(1,0){\line(1,0){1}}
%\put(1,1){\makebox(1,1){\(\sphericalangle\)}}
%\put(7,2){\makebox(1,1){\(\$\)}}
%\end{picture}
%\end{center}
%\caption{\label{labirintus}Labirintus bejárása}
%\end{figure}

%laptörés:
\newpage
%
Külön fájlban elkészített grafika beillesztését a 
%\ref{abra-automata} ábra szemlélteti.
%\begin{figure}[h]
%\centering
%%A psfrag csomag használatával a (encapsulated)postcript abra feliratait LaTeX koddal helyettesíthatjük:
%\psfrag{a}[c][c]{$q_0$}
%\psfrag{b}[c][c]{$q_1$}
%\psfrag{c}[c][c]{$q_2$}
%\psfrag{d}[c][c]{$q_3$}
%\psfrag{e}[c][c]{$q_4$}
%\psfrag{f}[c][c]{$q_5$}
%\psfrag{g}[c][c]{$q_6$}
%\psfrag{h}[c][c]{$q_7$}
%\psfrag{0}[c][c]{$a_{0}$}
%\psfrag{9}[c][c]{$a_{9}$}
%\psfrag{3}[c][c]{$a_{3}$}
%\psfrag{12}[c][c]{$a_{12}$}
%\psfrag{15}[c][c]{$a_{15}$}
%%Garfika belillesztese, "scale2 a nagyitas/kicinyites merteke, itt 80%.
%\includegraphics[scale=0.8]{abra.eps}
%\caption{\label{abra-automata} A $4\times m$-es tábla lefedéseinek mátrixreprezentációit felismerõ automata}
%\end{figure}


\chapter{Függelék}

\section{A program forráskódja}
%A függelékbe kerülhetnek a hosszú táblázatok, vagy mondjuk egy programlista:
%% A verbatim kornyezet hasznalatanal ügyeljünk rá, hogy az editor a szóközöjket át ne írja tab karakterekre!
%\begin{verbatim}
%   while (ujkmodosito[i]<0)
%   {
%      if (ujkmodosito[i]+kegyenletes[i]<0)
%      {
%         j=i+1;
%         while (j<14)
%         if (kegyenletes[i]+ujkmodosito[j]>-1) break;
%         else j++;
%         temp=ujkmodosito[j];
%         for (l=i;l<j;l++) ujkmodosito[l+1]=ujkmodosito[l];
%         ujkmodosito[i]=temp;
%      }
%      i++;
%   }
%\end{verbatim}


\chapter*{Nyilatkozat}
%Egy üres sort adunk a tartalomjegyzékhez:
\addtocontents{toc}{\ }
\addcontentsline{toc}{section}{Nyilatkozat}
%\hspace{\parindent}

% A nyilatkozat szövege más titkos és nem titkos dolgozatok esetében.
% Csak az egyik tipusú myilatokzatnak kell a dolgozatban szerepelni
% A ponok helyére az adatok értelemszerûen behelyettesídendõk es
% a szakdolgozat /diplomamunka szo megfeleloen kivalasztando.


%A nyilatkozat szövege TITKOSNAK NEM MINÕSÍTETT dolgozatban a következõ:
%A pontokkal jelölt szövegrészek értelemszerûen a szövegszerkesztõben és
%nem kézzel helyettesítendõk:

\noindent
Alulírott Varga Tamás programtervezõ informatikus BSc szakos hallgató, kijelentem, hogy a dolgozatomat a Szegedi Tudományegyetem, Informatikai Tanszékcsoport Számítógépes Optimalizálás Tanszékén készítettem, programtervezõ informatikus BSc diploma megszerzése érdekében.

Kijelentem, hogy a dolgozatot más szakon korábban nem védtem meg, saját munkám eredménye, és csak a hivatkozott forrásokat (szakirodalom, eszközök, stb.) használtam fel.

Tudomásul veszem, hogy szakdolgozatomat a Szegedi Tudományegyetem Informatikai Tanszékcsoport könyvtárában, a helyben olvasható könyvek között helyezik el.

\vspace*{2cm}

\begin{tabular}{lc}
Szeged, \today\
\hspace{2cm} & \makebox[6cm]{\dotfill} \\
& aláírás \\
\end{tabular}


\vspace*{4cm}



%% Az itrodalomjegyzek keszitheto a BibTeX segedprogrammal:
%\bibliography{diploma}
%\bibliographystyle{plain}

%VAGY "kézzel" a következõ módon:

\begin{thebibliography}{9}
%10-nél kevesebb hivatkozás esetén
\bibitem{Borkóstolás projekt}Borkóstolás projekt - http://www.inf.u-szeged.hu/~tnemeth/osa/

\bibitem{PageRank}Sergey Brin and Lawrence Page. The anatomy of a large-scale hypertextual web search engine. 
\emph{ Computer Networks and ISDN Systems},
vol. 30, no 1, 107-117, 1998

\bibitem{HITS}J. Kleinberg. Authoritative sources in a hyperlinked environment.
\emph{Journal of the ACM}, vol. 46, no. 5, 604-632, 1999

\bibitem{Github}GitHub - https://github.com/about

\bibitem{CoHITS}London András és Csendes Tibor. HITS based network algorithm for evaluating the professional skills of wine tasters

\bibitem{php-login}Panique. http://www.php-login.net
\emph{http://opensource.org/licenses/MIT MIT License}

\bibitem{php-history}History of PHP. http://php.net/manual/en/history.php.php

\bibitem{CSS-origin}Lie, Hakon W (10 Oct 1994). Cascading HTML style sheets - a proposal

\bibitem{PDO-charset-security}http://wiki.hashphp.org/PDO\_Tutorial\_for\_MySQL\_Developers\#Connecting\_to\_MySQL

%\begin{thebibliography}{99}
% 10-nél több hivatkozás esetén

\addcontentsline{toc}{section}{Irodalomjegyzék}

%Elso szerzok vezetekneve alapjan ábécérendben rendezve.


%folyóirat cikk: szerzok(k), a folyóirat neve kiemelve,
%az evfolyam felkoveren, zarojelben az evszam, vegul az oldalszamok es pont.

%\bibitem{Gischer}
%J. L. Gischer,
%The equational theory of pomsets.
%\emph{Theoret. Comput. Sci.}, \textbf{61}(1988), 199--224.

%könyv (szerzo(k), a könyv neve kiemelve, utana a kiado, a kiado szekhelye, az evszam es pont.)

%\bibitem{Pin}
%J.-E. Pin,
%\emph{Varieties of Formal Languages},
%Plenum Publishing Corp., New York, 1986.





\end{thebibliography}




\end{document}
